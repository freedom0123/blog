# 并发编程基础

## 一、概述

JUC 是 `java.util.concurrent` 包的简称，在 Java 5.0 之中添加，目的就是为了更好的支持高并发任务，让开发者进行多线程编程的时候减少竞争条件和死锁的问题。

当一个程序被运行的时候，从磁盘中加载这个程序的代码到内存之中，这时候就开启了一个**进程**，进程是系统进行资源分配和调度的基本单位，每个进程都有自己独立的内存空间的系统资源，而 **线程** 是进程中的一个实体，存在于进程之中。

### 1.1 创建线程

在 Java 之中，有三种创建线程的方式，分别是：

1）继承 Thread 类

2）实现 Runnable 接口

3）实现 Callable 接口：和 Callable 配合使用的有一个Future类，通过这个类可以了解任务执行情况，或者取消任务的执行，获取执行结果

### 1.2 用户线程 和 守护线程

Java线程分为用户线程 和 守护线程，线程的 daemon 属性是 true 是守护线程，false 是用户线程

- **守护线程**：一种特殊的线程，专门为用户线程提供服务的线程，生命周期依赖于用户线程，只有 JVM 中仍然存在用户线程正在运行的时候，守护线程才有存在的意义，否则，一旦JVM进程结束，守护线程也会随之结束。比如垃圾回收线程
- **用户线程**：是系统的工作线程，他会完成这个程序需要完成的业务操作

:::info

如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以系统只剩下了守护线程的时候，JVM会自动退出

:::

## 二、线程的状态

在通用的线程生命周期之中，线程具有如下的状态：

![画板](asserts/1651817912167-9696d6fc-371d-451e-9dac-e3e5e6b4ca54.jpeg)

但是对于Java来讲，他对运行和可运行状态进行了简化，并对休眠状态进行了细化。在Java中提供了这6种线程状态。



![](asserts/image-202502112150.png)

## 三、管程
`Monitor`，监视器，也就是我们平时所说的锁，其实是一种同步机制，他的义务就是保证同一时间只有一个线程可以访问被保护的数据和代码。JVM 中同步是基于进入和退出监视器对象来实现的，**<font style="color:#2F54EB;">每个对象实例都会有一个  Monitor  对象，Monitor  对象会和  Java对象  一同创建和销毁</font>**，底层使用  C++语言 实现。**<font style="color:#2F54EB;">执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成时释放管程</font>**。在方法执行期间，执行线程持有了管程，其他任何线程都无法在获取到同一个管程。

对于一个监视器对象，具有如下的属性：

| _owner | 指向持有ObjectMonitor对象的线程 |
| :---: | :---: |
| _WaitSet | 存放处于  wait状态 的线程队列 |
| _EntryList | 存放等待锁释放状态的线程队列 |
| _recursions | 锁的重入次数 |
| _count | 用来记录该线程获取锁的次数 |

比如说，下面这个示例

:::=tabs
::源代码

```java
new Thread(() -> {
    synchronized (TestSynchronized.class) {
        System.out.println("ThreadA");
        try {
            TestSynchronized.class.wait();
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
    }
},"ThreadA").start();

new Thread(() -> {
    synchronized (TestSynchronized.class) {
        System.out.println("ThreadB");
    }
},"ThreadB").start();

new Thread(() -> {
    synchronized (TestSynchronized.class) {
        System.out.println("ThreadC");
    }
},"ThreadC").start();
```

::对应的监视器
![](asserts/image-20250212-monitor.drawio.png)
:::

## 四、线程之间协作

### 4.1 join

在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。

join 方法会释放CPU，底层调用的仍然是wait方法

```java
Thread threadA = new Thread(() -> {
    log.info("ThreadA");
    try {
        TimeUnit.SECONDS.sleep(10);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    }
});
threadA.start();
threadA.join();
log.info("Main Thread");
```

执行效果如下：

```markdown
20:44:15.699 [Thread-0] INFO com.coding.join.TestJoin - ThreadA
20:44:25.715 [main] INFO com.coding.join.TestJoin - Main Thread
```

如果不加 join 方法，则对应的执行效果如下

```markdown
20:45:13.787 [main] INFO com.coding.join.TestJoin - Main Thread
20:45:13.787 [Thread-0] INFO com.coding.join.TestJoin - ThreadA
```

对于 join 方法，底层仍然是通过 wait 方法来完成的

### 4.2 wait() notify() notifyAll()

对于这几个方法实际上都是和管程对象密切相关的，只能在 同步方法或者同步代码块之中执行。

他们都属于 Object 的一部分，而不属于 Thread 方法。

|      方法      | 含义                                                         |
| :------------: | ------------------------------------------------------------ |
|    notify()    | 通知一个在对象上等待的线程，使其从wait方法返回，而返回的前提是该线程获取了对象的锁 |
|  notifyAll()   | 通知所有等待在该对象上的线程                                 |
|     wait()     | 调用该方法的线程进入等待状态，只有等待另外线程的通知或者被中断才被放回。 |
|   wait(long)   | 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n秒    |
| wait(long,int) | 对于超时时间更细粒度的控制，可以达到毫秒级别                 |

当调用 wait 方法之后，线程就会进入 Monitor 对象的 wait 队列之中等待，当调用 notify 方法之后，就会唤醒 wait 队列的线程。

进入 wait 之后，就会释放出当前持有的 Monitor 对象。

> 场景：三个线程轮流打印 ABC

```java
private static int state = 0;

Object lockA = new Object();

new Thread(()->{
    for (int i = 0; i < 10; i++) {
        synchronized (lockA) {
            while (state != 0) {
                try {
                    lockA.wait();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            System.out.println("A");
            state = 1;
            lockA.notifyAll();
        }
    }

}).start();

new Thread(()->{
    for (int i = 0; i < 10; i++) {
        synchronized (lockA) {
            while(state != 1) {
                try {
                    lockA.wait();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            System.out.println("B");
            state = 2;
            lockA.notifyAll();
        }
    }
}).start();

new Thread(()->{
    for (int i = 0; i < 10; i++) {
        synchronized (lockA) {
            while(state != 2) {
                try {
                    lockA.wait();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            System.out.println("C");
            state = 0;
            lockA.notifyAll();
        }
    }
}).start();
```

### 4.3 await() signal() signalAll()

JUC 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。

> 场景：三个线程轮流打印 ABC 

```java
Lock lock = new ReentrantLock();
Condition conditionA = lock.newCondition();
Condition conditionB = lock.newCondition();
Condition conditionC = lock.newCondition();

new Thread(()->{
    for (int i = 0; i < 10; i++) {
        lock.lock();
        while (state != 0) {
            try {
                conditionA.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println("A");
        state = 1;
        conditionB.signal();
        lock.unlock();
    }

},"A").start();

new Thread(()->{
    for (int i = 0; i < 10; i++) {
        lock.lock();
        while (state != 1) {
            try {
                conditionB.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println("B");
        state = 2;
        conditionC.signal();
        lock.unlock();
    }

},"B").start();

new Thread(()->{
    for (int i = 0; i < 10; i++) {
        lock.lock();
        while (state != 2) {
            try {
                conditionC.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println("C");
        state = 0;
        conditionA.signal();
        lock.unlock();
    }

},"C").start();
```

## 五、并发编程Bug的源头

### 5.1 可见性

一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称之为**可见性**。

在单核 CPU 下，所有线程操作的都是同一个 CPU 的缓存，一个线程更改了缓存之后，对于另一个线程而言一定是可见的。但是在多核时代，每颗CPU都有自己的缓存，当多个线程在不同的CPU上执行的时候，这些线程操作的是不同的CPU缓存。

比如下面这个示例：

```java
public class Test7 {
    public static void main(String[] args) throws InterruptedException {
        int count = 0;
        Thread t1 = new Thread(()->{
            for(int i = 0; i < 10000; i++) count += 1;
        });
        Thread t2 = new Thread( ()-> {
             for(int i = 0; i < 10000; i++) count += 1;
        });
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(resource.getCount());
    }
}
```

对于上述的代码，我们可能想会得到一个 20000 的结果，但是结果不是，通过运行，最终会得到一个随机数。

我们假设两个线程是同时开始执行的，那么一开始都会将 count 读到各自的CPU缓存中，基于各自的CPU缓存中的 count 进行计算，最终导致结果的不确定性，这就是缓存的可见性问题,   出现这种问题的原因主要是缓存，这种问题也被称之为【缓存一致性问题】

![](asserts/1650384100969-942c0474-4c3f-43dc-aaad-ddda859de94d.png)



对于上述的代码，我们可能想会得到一个20000的结果，但是结果不是，通过运行，最终会得到一个随机数。

我们假设两个线程是同时开始执行的，那么一开始都会将count 读到各自的CPU缓存中，基于各自的CPU缓存中的count进行计算，最终导致结果的不确定性，这就是**<font style="color:#E8323C;">缓存的可见性问题</font>**

### 5.2 原子性

OS 做任务切换的时候，可以发生在任何一条CPU指令执行完成之后，而不是高级语言的一条语句。就比如 count + 1 指令。

对于程序而言，就是一条语句，但是实际上至少需要 3 条 CPU 指令。

- 将 count 从 内存读取到 CPU 的寄存器
- 在寄存器中执行 +1 操作
- 将结果写入到内存之中

可能在执行第二条指令的时候，CPU 进行了任务的切换。就比如下面这样

![](asserts/1650384272988-307012ca-2e14-4f8c-9a9c-c16863b29915.jpeg)

我们把一个或者多个操作在CPU执行的过程中不被打断的特性称之为**<font style="color:#E8323C;">原子性，解决原子问题的关键，就是保证中间状态对外不可见</font>**

### 5.3 有序性

当我们把代码写好之后，虚拟机并不一定会按照我们写的代码的顺序来执行。如果优化后，将代码顺序改变之后，也称之为重排序，这些重排序可能会导致多线程内存可见性问题，这种问题我们称之为**【有序性问题】**

重排序分3种类型：

+ **编译器优化的重排序**。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序
+ **指令级并行的重排序**。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
+ **内存系统的重排序**。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行

![](asserts/1661147096315-9012d78e-702c-448f-896c-5060d9cdb79e.png)

## 六、内存模型

导致可见性的原因是缓存，导致有序性的原因是编译优化，解决可见性和有序性 的办法就是禁用缓存和编译优化。虽然说问题解决了，但是程序的性能就会带来影响。合理的方案就是  **按需禁用缓存以及编译优化**。

JMM 规范了 JVM 如何提供**按需禁用缓存 和 编译优化**的方式。其中包括：

- volatile
- synchronized
- final
- Happens-Before 规则

#### 6.1 volatile

当声明一个 volatile 变量的时候，表示告诉编译器，对于这个变量的读写，不能使用 CPU 缓存，必须从内存之中读取或者写入。

#### 6.2 Happens-Before 规则

对于重排序优化，造成多线程内存可见性的问题，JMM 通过要求 Java 编译器在生成指令序列的时候插入内存屏障来解决。其中主要包括

| 类型       | 示例                       | 说明                                                         |
| ---------- | -------------------------- | ------------------------------------------------------------ |
| LoadLoad   | load1； LoadLoad； load2   | 确保 load1 数据的装载先于 load2 以及后续所有装载指令         |
| StoreStore | Store1；StoreStore；Store2 | 确保 Store1 数据刷新内存先于 Store2 及后续存储指令的存储     |
| LoadStore  | Load1；LoadStore；Store    | 确保 Load1 数据装载先于 Store2 及后续所有的内存指令刷新到内存 |
| StoreLoad  | Store1；StoreLoad；Load2   | 确保 Store1 的操作结果刷新到内存先于 Load2及后续所有装载指令的装载 |

从 JDK 5 开始，Java使用新的 JSR-133 内存模型。JSR-133 使用 `happens-before`  的概念来阐述操作之间的内存可见性。

**在 JMM 中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。**

::: tip

一条 happens-Before 规则都是通过一个或者多个禁止重排序来完成的

:::

提供的规则如下：

1. `次序规则`：一个线程内，按照代码顺序，写在前面的代码先行发生于写在后面的代码
2. `锁定规则`：对于一个锁的解锁，happens-before于随后对这个锁的加锁
3. `volatile变量规则`：对于一个volatile变量的写，happens-before于后续对这个volatile变量的读
4. `传递规则`：如果说A 先行发生于 B，B又先行发生于C，可以得出 A 先行发生于 C
5. `线程启动规则`：Thread对象的start()方法先行发生于此线程的每一个动作
6. `线程中断规则`：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
7. `线程终止规则`：线程中的所有操作都先行发生于对此线程的终止检测
8. `对象终结规则`：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始