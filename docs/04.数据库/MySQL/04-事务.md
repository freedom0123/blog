# 一、基本信息
![](https://cdn.nlark.com/yuque/0/2024/png/22570918/1726969297206-cfafde41-9596-4367-996f-d39a20163796.png)



```markdown
# begin [work]

  1. 开启事务
  
# start transaction [修饰符1,修饰符2.......]

  1. 相比于begin，在该语句后面可以跟修饰符,但是注意 read only 和 read write 不能同时存在
  
  2. read only：只读事务，属于该事务的数据库只能进行读操作
  
  3. read write：读写事务
  
  4.  with consistent snapshot：启动一致读

# commit
  
  1. 提交事务
  
# rollback

  1. 回滚
  
  2. 该语句是我们程序员进行手动回滚的时候，才会进行使用
  
  3. 如果说事务在执行过程中遇见某些错误而无法基于执行，事务自身会自动进行回滚
  
# 自动提交

  1. show variables like 'autocommit';
  
  2. 通过上面这条语句，默认情况下，该值为 on
  
  3. 也就是说如果说我们不使用语句显示开启一个事务，那么每一条语句都算一个独立的事务，这种特性我们称之为 `事务的自动提交`
  
  4. 如果说我们想关闭这种自动提交，我们可以通过显式的开启事务 或者将 `autocommit`设置为`OFF`
  
# 保存点

  1. savepoint 保存点;
  
  2. 回滚到某个保存点 `rollback [work] to [savepoint] 保存点名称`
  
  3. 删除保存点：relese savepoint 保存点名称
  
```

# 二、 隔离级别
## 2.1  并行事务存在的问题
### 2.2.1 脏读
脏读，是指一个事务，读取到了另一个事务还没有提交的信息

![脏读](https://cdn.nlark.com/yuque/0/2022/jpeg/22570918/1658733342169-55aed758-4e73-4d1a-b63e-3a23e01ac86b.jpeg)

### 2.2.2 不可重复读
在一个事务之中多次读取同一个数据，如果说前后两次读取到的数据不一致。

![](https://cdn.nlark.com/yuque/0/2022/jpeg/22570918/1658733481439-d4a390b6-fd76-4abb-9b55-dff15f3c802a.jpeg)

### 2.2.3 幻读
在一个事务内多次查询某个符合查询条件的记录数量，前后两次查询到的记录数量不一致

![](https://cdn.nlark.com/yuque/0/2022/jpeg/22570918/1658733564916-54c6a165-5b89-4a0e-973f-6ef1033b6de0.jpeg)

## 2.2  隔离级别
![](https://cdn.nlark.com/yuque/0/2024/png/22570918/1726989338257-58c317b2-459e-46e2-bad1-2ebd1f4128a7.png)

:::tips
注意：隔离级别从小到大安全性越来越高，但是效率会越来越低

:::

```sql
-- 显示数据库的默认隔离级别
show variables like 'transaction_isolation';

-- 设置事务的隔离级别
set [global | session] transaction isolation level 隔离级别;
```

+ `global`
    - 只对执行完该语句之后产生的会话起作用
    - 当前已经存在的会话无效
+ `session`
    - 对当前会话的所有后续的事务有效
    - 如果在事务之间执行，则对后续的事务有效

# 三、 MVCC 原理
多版本并发控制，指的就是使用`read committed`和`repeatable read`这两种隔离级别的事务在执行普通的`select`操作的时候访问记录的版本链的过程，这样子可以使不同事务的`读-写` 、`写-读`操作并发执行， 从而提升系统的性能。MVCC是基于数据版本对并发事务进行访问

在 undo log 之中，我们提到，对于一行记录的回滚指针，它实际上是指向这个事务对应的 undo log 的，并且在这行记录之中会存储本次事务对应的事务 ID 的。

:::tips
那么如果说两个事务，同时在对同一行记录进行操作呢？这个事务 ID 是哪一个？这种情况实际上就是一个事务修改了另一个事务对应的数据，我们称之为这种情况为脏写，这种情况不管在那种隔离级别之下都是不允许发生的，内部通过锁的方式来保证，一个事务必须等另一个事务提交之后，才能能够继续更新。

:::

所以，实际情况就如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/22570918/1726989971988-207b1882-8fa6-4b93-a7d4-75df63ae414b.png)



组成的这一条链，称之为版本链。版本链的头结点对应当前记录最新的值。在 undo log 之中，还会携带生成该版本是对应的事务 ID。

对于读未提交来说，他可以读取到其他事务未提交的数据，所以直接读取记录的最新的版本就好了。对于可串行化，通过锁的方式来控制，对于使用读已提交和可重复读隔离级别的事务来说，都必须保证读到已经提交了的事务修改过的记录，也就是说假如另一个事务已经修改了记录但是尚未提交，是不能直接读取最新版本的记录的，核心问题就是需要判断一下版本链中那个版本是当前事务可见的。为此，提出了`ReadView`。在 Read View 之中，他包含了如下的内容：

+ `m_ids`：生成`ReadView`时当前系统中活跃的读写事务的事务id列表
+ `min_trx_id`：m_ids 中的最小值
+ `max_trx_id`：m_ids 中的最大值
+ `creator_trx_id`：生成该`ReadView`的事务的事务id

当具备了 ReadView 的时候，我们来看一下，读取一条数据对应的流程：

+ <font style="color:rgb(51, 51, 51);">如果被访问版本的</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">trx_id</font>`<font style="color:rgb(51, 51, 51);">属性值与 </font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">ReadView</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);"> </font><font style="color:rgb(51, 51, 51);">中的 </font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">creator_trx_id</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);"> </font><font style="color:rgb(51, 51, 51);">值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</font>
+ <font style="color:rgb(51, 51, 51);">如果被访问版本的</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">trx_id</font>`<font style="color:rgb(51, 51, 51);">属性值小于</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">ReadView</font>`<font style="color:rgb(51, 51, 51);">中的</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">min_trx_id</font>`<font style="color:rgb(51, 51, 51);">值，表明生成该版本的事务在当前事务生成</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">ReadView</font>`<font style="color:rgb(51, 51, 51);">前已经提交，所以该版本可以被当前事务访问。</font>
+ <font style="color:rgb(51, 51, 51);">如果被访问版本的</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">trx_id</font>`<font style="color:rgb(51, 51, 51);">属性值大于或等于</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">ReadView</font>`<font style="color:rgb(51, 51, 51);">中的</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">max_trx_id</font>`<font style="color:rgb(51, 51, 51);">值，表明生成该版本的事务在当前事务生成</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">ReadView</font>`<font style="color:rgb(51, 51, 51);">后才开启，所以该版本不可以被当前事务访问。</font>
+ <font style="color:rgb(51, 51, 51);">如果被访问版本的</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">trx_id</font>`<font style="color:rgb(51, 51, 51);">属性值在</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">ReadView</font>`<font style="color:rgb(51, 51, 51);">的</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">min_trx_id</font>`<font style="color:rgb(51, 51, 51);">和</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">max_trx_id</font>`<font style="color:rgb(51, 51, 51);">之间，那就需要判断一下</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">trx_id</font>`<font style="color:rgb(51, 51, 51);">属性值是不是在</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">m_ids</font>`<font style="color:rgb(51, 51, 51);">列表中，如果在，说明创建</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">Rea dView</font>`<font style="color:rgb(51, 51, 51);">时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建</font>`<font style="color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);">ReadView</font>`<font style="color:rgb(51, 51, 51);">时生成该版本的事务已经被提交，该版本可以被访问。</font>

<font style="color:rgb(51, 51, 51);">那么 read view 是什么时候生成的呢？</font>

+ `read committed`在每次一次进行普通select操作的时候生成一个ReadView
+ `repeatable read`只在第一次进行普通select操作前生成一个ReadView，后面会复用这个`ReadView`，版本链不会发生变化，所以说不会出现重复读的问题。

# 四、杂谈
![](https://cdn.nlark.com/yuque/0/2024/png/22570918/1727310773654-e3259766-2424-456d-8bf4-36a483114354.png)

为什么，我并没有开启事务，为什么读取不到最新的数据呢？

 对于任何一条语句而言，如果没有显式的开启事务，都会有一个默认的事务。

